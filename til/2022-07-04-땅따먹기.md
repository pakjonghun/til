---
date: 2022-07-02
category: til, algo
---

## 문제

- 길이가 4이고 안에 숫자가 들어있는 배열이 모여있는 2차 배열이 있다.
- 숫자가 들어있는 각 배열을 순회하면서
- 적당히 큰 수를 고르고, 또 다음 배열로 이동해서
- 또 큰 수를 고르는데 이때 이전에 골랐던 배열의 index 가 아닌 수를 골라야 한다.
- 이런식으로 숫자를 모두 골랐을때 가장 큰 수가 나오도록 함수를 만들어라!

## 풀이

- 처음에는 문제 그대로 풀음(결과 실패 정확도 x)
  - 가장 큰수를 고르고 그 인덱스를 다음 배열에서 빼고 고르고 하면
  - 쉽게 함수를 만들수는 있지만 실제로 가장 큰 수가 나오지 않는다.
- 두번째는 dps 를 이용해서 모든 경우의 수를 구했다.(결과 실패 시간초과)
  - 효율성도 따져야 하는 문제였고 결국 실패했다.
- 결국 문제를 각각 쪼개서 분할 정복 해야 한다는 것을 알게되었고 고민을 많이 했다.(통과)

  - 고민해도 해도 답이 안나와서 질문 글에 dp 계산 방식을 보고 힌트를 얻었는데
  - 2차 배열 에서 고른 수 외 다른 숫자를 가져와서 더하고 또 다음 배열에서 똑같이 하면서 계속 누적 해서 더하는 방식을 참고했고
  - 그대로 함수를 작성해서 통과할 수 있었다.
  - 참.. 쉬워 보이면서도 어려운 문제였다. 정말 생각을 전환해서 고민하는 연습을 많이 해야 겠다고 생각했다.

  ```
    function solution(land) {
      for (let i = 1; i < land.length; i++) {
        land[i][0] += Math.max(land[i - 1][1], land[i - 1][2], land[i - 1][3]);
        land[i][1] += Math.max(land[i - 1][0], land[i - 1][2], land[i - 1][3]);
        land[i][2] += Math.max(land[i - 1][0], land[i - 1][1], land[i - 1][3]);
        land[i][3] += Math.max(land[i - 1][0], land[i - 1][1], land[i - 1][2]);
      }

      return Math.max(...land[land.length - 1]);
    }

  ```
