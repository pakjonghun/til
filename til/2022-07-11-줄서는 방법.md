---
date: 2022-07-10
category: til,algo
---

## 문제(순열 문제)

- n명의 사람이 일렬로 줄을 서고 있습니다.
- n명의 사람들에게는 각각 1번부터 n번까지 번호가 매겨져 있습니다.
- n명이 사람을 줄을 서는 방법은 여러가지 방법이 있습니다.
- 예를 들어서 3명의 사람이 있다면 다음과 같이 6개의 방법이 있습니다.

[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
사람의 수 n과, 자연수 k가 주어질 때, 사람을 나열 하는 방법을 사전 순으로 나열 했을 때, k번째 방법을 return하는 solution 함수를 완성해주세요.

제한사항
n은 20이하의 자연수 입니다.
k는 n! 이하의 자연수 입니다.

## 풀이

- n 명을 줄 세우는 방법은 순열이다.
- 단 순열 방식으로 모든경우의 수를 다 구하면 시간초과가 떠서 실패한다.
- k 번째 만 구하는 방법을 생각해야 한다.
- 먼저 맨 앞자리를 보면 3명을 1줄로 세우려면
- [1,2,3],[1,3,2],[2,1,3,],[2,3,1],[3,1,2],[3,2,1] 6가지경우가 있고
- 위경우는 맨 앞에 1 2 3 이 각각 2번(총 6개 경우의 수 / 3명) 씩 반복되며
- 그 다음 숫자역시 똑같은 방식으로 맨 앞의 수 제외한 나머지수 로 반복된다.
- 이 방식을 적용해서 풀어 보면

```
 function factorial(n) {
    let s = 1;
    for (let i = 2; i < n + 1; i++) s *= i;
    return s;
  }

  function solution(n, k) {
    //줄세울 사람 리스트
    const arr = Array.from({ length: n }, (_, i) => i + 1);

    //정답을 넣을 배열
    const answer = [];

    //줄세우는 경우에서 몇번째가 될지의 인덱스를 정하는 변수(array 에서 계속 사람을 빼 줄거라서 index 로 변환해야함 -1)
    let newK = k - 1;

    //정답에 줄세울 사람 다 차면 종료 한다.
    while (answer.length !== n) {

      //몇번 반복되는지 =  전체 경우의수 나누기 남은 사람수 로 구하고
      //전체경우의 수(factorial(n)) 나누기 n  = factorial(n-1)
      const repeat = factorial(arr.length - 1);

      //맨 앞 자리수를 구해주고 Math.floor() 방법을 사용하다가 다른사람 풀이를 보고 >> 라는 것을 알게 되서 적용해 보았다.
      //>> 는 숫자 부호도 그대로 적용되고 연산 후 순위로 알아서 순서도 정해져 있다.
      const index = newK / repeat >> 0;

      //한자리씩 맨 앞에 설 사람을 answer 에 모으고
      answer.push(arr[index]);

      //줄을 선 사람은 빼주고
      arr.splice(index, 1);

      //그 다음 남은 사람들로 줄 세울때 경우의 수 중 번째수 즉 2번째 k
      //이 값은 앞에 줄선 사람 구한 다음 남은 나머지 가 된다.
      //이 값은 줄세울 사람 수 - 1 에서 0 사이가 되는데
      //그래서 앞에 줄 선 사람 빼고 나머지 사람들끼리 다시 줄 세울때
      //나머지 사람들을 줄 세우는 경우의 수의 몇번째 경우의 수가 될지 제 2의 k 가 된다.
      newK = newK % repeat;
    }

    return answer
  }

```

## 느낀점

- 처음에 완전 지저분 했던 코드를 다른사람 풀이를 보고 많이 바꾸었다.
- 바꾸면서 while 에 어떤 조건을 넣을지 고민을 해야 된다는 생각을 하게 됬다(잘못 넣으면 엄청 복잡해 질 수가 있음.)
- 일단 while 에 조건을 true 로 넣고 식을 짜면서 도출되는 조건을 고민하면서
- while 의 메인 조건으로 넣어줘야 할 것 같았다.
- 신기한점, 모르겠는 점
  - 변수를 다시 선언하지 않고 args 를 재활용해서 풀은 풀이가 있길래 따라해봤는데 시간초과가 뜬다. 다른점은 그것 하나 뿐인데 왜 시간초과가 되는지 이해가 잘 안된다.(웬만하면 파마니터 변수는 건들지 말고 변경될 경우 재 선언 할당 하는 방법을 써야겠다.)
