---
date: 2022-08-06
category: til, algo
---

## 문제

- n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

- 처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

- 모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

- 입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

## 풀이

- 처음에는 배열에 1 부 사람숫자까지 모든수를 곱한후(모든 걸리는 시간 경우의 수)배열로 만들었다.
- 그리고 오름차순으로 정렬 한 후 n 번째 값을 반환 하는 식으로 풀려고 했다.
- 결과는 실패 저장공간 제한이 있었는데 그것을 무시했기 때문이었다.
- 고민하다가 이분탐색이라는 힌트를 질문 게시판에서 보고 다시 풀었다.
- 풀다가 안풀려서 아예 스포 풀이를 보고 반복해서 풀어보았다 이분탐색은... 왜케 이해가 안되는 걸까
- 풀면서 하나하나 따져보면서 이해를 할 수 있었고, 혼자서도 코드를 잘 작성 할 수 있게 되었지만
- 아직 응용을 하라고 하면 잘 못할 것 같다.

```
  function solution(n, times) {

    //가장 적게 걸리는 시간은 가장 작은 시간이 걸리는 심사대에서 1명만 처리 할 경우
    //그러나 이분법을 위해서 일단 가장 적은 시간이 걸리는 심사대를 고른다.
    let min = Math.min(...times);

    //가장 많이 걸리는 시간은 1개의 심사대만 있는데 그 심사대가 n 명을 모두 처리할 경우
    //그러나 이분법을 위해서 일단 가장 시간이 오래 걸리는 심사대 기준으로 가장 많은 시간 걸리는 경우를 구한다.
    let max = Math.max(...times) * n;

    //이분탐색 적용(중간시간을 구해서 이 시간안에 모두 심사 가능한지 판단해서 mid 에서 +1 -1 해줌)
    while (min <= max) {
      const mid = Math.floor((min + max) / 2);
      const sum = times.reduce((acc, cur) => acc + Math.floor(mid / cur), 0);

      if (sum < n) min = mid + 1;
      else max = mid - 1;
    }
    return min;
}
```
