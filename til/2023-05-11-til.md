---
date: 2023-05-11
category: til,pattern
---

## pattern

- 객체지향 적인 사고와 원활한 소통을 위해 패턴을 공부중이다.(울 회사에서 많이씀.ㅠ ㅠ )

  - 옵저버 패턴 : 구독 했으니 데이터 바뀔때마다 알려줘~

    - pubsub 과는 다르다(pubsub 을 따로 알아봐야 할듯)
    - 간단히 구독 후 업뎃 된 데이터를 전달받는 패턴이다.
    - 실제 실행되는 display 와 data 가 서로 모르는 상태에서 느슨하게 결합된다.
    - 왜 느슨한가 살펴보니 모두 다른 인터페이스를 사용하고 있고
    - 중간에 옵저버 클래스가 각 클래스를 주입받아 느슨하게 결합하고 있기 때문임
    - ocp 를 지키면서, 각 인스턴스가 자기 일만 충실하게 하고 있는 멋진 패턴 으로 보였다.
    - subject 인터페이스를 구현한 데이터를 관리하는 클래스를 만들고!!
    - 이 데이터를 구독 할 display 가 있다면 이 디스플레이와 옵저버를 함께 구현한다.
      ```
        class Display1 implements Display, Observer{
          update()
          display()
        }
      ```
    - 이 디스플레이 1을 subject 로 구현한 데이터에 register 한 다음에
    - register 할때 subject 에 멤버변수로 display 를 할당해뒀다가!
    - notify 할 때마다 display 의 update 를 실행하면 된다.
    - client 에서 display 의 display 를 실행 할때는 항상 update 된 데이터가 유지 될 수 있다.
    - 문제는 내가 이 패턴을 구현할 일이 있을까???

      ```
        interface Subject{
          register()
          remove()
          notify()
        }

        interface Observer{
          update()
        }

        interface Display{
          display()
        }
      ```

- factory pattern : 인스턴스 생성역할을 분리!
  - 패턴이라기 보다는 자주 쓰이는 관용구 정도로 보면 될 것 같다.
  - new Instance() 를 캡슐화 시켜서 분리 한다.
  - 분리됨으로써 느슨한 결합이 유지되고(이 부분은 의존성을 따져봐야함)
    - classA 를 상속하는 다른 클래스는 모두 A 를 의존하게 된다.
    - classA 를 여러개 갖고 있거나 조건부로 생성하는 store 가 있다면 그 store 도 A 에 의존해야 할 것 같지만...
    - 실제로는 각 생성된 classA 를 의존하는 다른클래스에 의존하게 된다.
    - 즉, 추상클래스가 아는 구상클래스(이미 구현된 클래스)에 의존하게 되어 단단한 결합이 되어 버린다.
    - 이렇게 되면 코드를 수정하는 곳이 많아지고, 유지보수가 힘들어짐.
    - 그래서 factory 를 별도로 빼서 classA 를 생성하는 조건분기 등의 처리를 해 버리면
    - 인스턴스 생성이라는 역할이 분리가 되고
    - classA 를 가진 각 클래스는(몇개가 어떤 조건이 붙던어쨋든 간에 암것도 몰라도됨.)
    - 오로지 추상 클래스 classA에 의존하게 되어 유지보수가 용이해 진다.
  - 그럼 분리를 해야 하니 모든 new 가 붙는 거는 factory 로 빼야겠네??
  - 또 그건 아니다 왜냐하면 굳이... 오버 엔지니어링 할 필요는 없기때문
  - 조건이 여러기 붙거나 자식 클래스가 2개 정도 생기면 그때부터해줘도 늦지 않다.
