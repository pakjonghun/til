---
date: 2023-09-13
category: til
---

## 개요

- 라우터 다이나믹 한 경로 관리 와 useRouteMatch 의 사용 시점
- 정말 겹치는 공통된 부분이 많은데 굳이 컴포넌트를 나눠야 할까요!!!!!?

## 문제인식

- useRouteMatch 를 왜케 남용했냐??;;;
  - 경로(route)에 상태값이 포함된 경우가 생겼다 이를테면 어떤 아이템의 아이디 같은 것들
  - 그런데 이 아이디가 그냥 아이디가 아니라 -> 글로벌하게 상태로 관리하고 있는 아이디 였다.
  - 여기서 문제가 생겼다
  - 글로벌한 아이디로서 상태를 업데이트 한 다음에 url 을 push 해야 하는지??
  - 아니면 순서를 반대로 해야 하는지??
  - 어떻게 하던간에 오류가 발생했다 -> 페이지를 찾을 수 없습니다.!!! ㅋㅋ
  - 아주 간단한 해결방법은 아이디를 바꾸고 푸시도 한 다음에 setTimeout 으로 딜레이를 500밀리세컨드 정도 줘 버리면 알아서 해결이 되었다.
  - 상태가 완전 업데이트 되서 동기화 되고 url 도 거기 맞춰서 변경 되는 시간이 0.5 초 정도 걸리는것 같았다.
  - 하지만 이 방법은 해결방법이 아니었다. 왜냐하면 사용자 컴퓨터 별로 이 딜레이 되는 시간이 천차만별일 것이기때문이다.
  - 그래서 안전빵인 라우트 변경 후 알아서 상태 변경이 되는 플로우로 진행하려고 코드를 뜯어보는데.
  - 아뿔싸.... subRoute 에서 useRouteMatch 가 너무 많이 사용되고 있었다(그냥 전부 다 사용중...)
  - 이렇게 되면 :itemId <-- 이런식으로 사용 한 것이 아니라서 라우트에서 페이지를 못찾는 상태가 버린다.....
- 정말 똑같은 페이지가 2개가 있었다. 그래 있었지... 근데 한 페이지에 인터페이스가 1개가 추가됬어... 망했어...
  - 정말 똑같아서 여러번 물어봤다. 안바뀌죠? 인터페이스도 똑같죠? 답변은 네네!!
  - 하지만 바뀌기 시작했다... 경고 에러 표시, 사용하는 메서드, 이에따른 인터페이스가 조금씩 차이가 나기 시작...
  - 중복되는게 너무 많은데 그래도 나눠야 하나요??
  - 중복되는 컴포넌트 다 분리하고 다시 조립해도...?
  - 중복되는 컴포넌트 따로 다 빼내고 페이지를 새로 조립해도 너무 페이지가 비슷해서 중복되는게 너무 많은데....
  - 그러니까 구조 자체가 똑같다보니 그냥 중복이다.
  - 이거 어떻하지????
  - 마침 인터페이스가 헷갈린다고, 이상하다고 문의가 와서... 나누거나 어떻게 하든 구분을 해야겠다는 결심을 했다.

## useRoutMatch 는 편리하지만

- useRoutMatch 를 사용하면 url 을 변수값으로 가지는 값이 나온다.
- 엄청 편하다 이거 쓰면 url 금방 알 아서 필요한 작업을 할 수 있다.
- 문제는 이것을 STATIC 한 자리에 사용 해 버린 것이다 .. 이런바보..
- useParam 이 왜 안되나 했더니 이런 이유가 다 있었다...
- 일단 url 이 너무 많고 복잡하니 크게 2갈래도 분리했다 Dynamic 과 Static
- static 은 :id 이런식으로 static한 url 을 반환하는 값들을 모아놓고, dynamic 은 입력받은 값에따라 다이나믹하게 변경되는 함수를 매핑시켰다.

  ```
    //뭐 대충 이런느낌으로??
    export const DYNAMIC_PATH = {
      PROJECT_SETTING: (projectId: string) => pathJoin('project', projectId, 'setting'),
      INSTANCE_LIST: (projectId: string) => pathJoin('project', projectId, ROUTE_PATH.INSTANCE),
    };

    export const STATIC_PATH = {
      INSTANCE_LIST: pathJoin('project', ':projectId', ROUTE_PATH.INSTANCE),
    };

  ```

- 그리고 모든 라우트를 위 객체를 이용해서 만들어 주었다.
- 그다음 상태를 바꾸는 장소도 url 을 기준으로 상태변경이 일어나게 바꿨다.
- 이제 주소를 푸시하면 -> 상태가 바뀌면서 상태가 동기화 될 것이다.
- 이에다른 상태가 동기화 되기 전에는 스피너나 다른 UI 나 등장하도록 수정 했다.
- 거참 엄청나게 고칠게 많아서... 힘들었다.

## UI 의 입장에서 생각하자!

- UI 가 거의 비슷하고 구조도 똑같은 페이지가 있지만
- 그 페이지를 재활용 할때마다 주입되는 data 의 인터페이스는 미세하게 다르다.
- 그렇다면! UI 의 인터페이스에 맞게 파싱을 하면되지!!!!!!!
- 통신따로 -> UI 랜더링 따로 생각하면 편하게 해결 할 수 있다.
- 이런 간단한 생각을 못하고 막 작성 한 이유는...
  - 그때는 이렇게 될 줄 몰랐거든... 결국 경험 부족인 인 것 같다.
- 결국 재활용하기 좋은 컴포넌트란 컴포넌트에서 필요한 인터페이스를 가 제대로 정의되어서
- 그 인터페이스 대로 작동하는 컴포넌트라는 것을 다시 한번 느낄 수 있었다.
- 그래서 어떻게 해결했냐면!!!!
- 먼저 방대한 페이지!!! 에 필요한 인터페이스를 별도로 정의했다. 인터페이스 이름을 InterfaceForSomeUI 이런식으로 ㅋㅋ 아주 명확하게 적어줬다.
- 그리고 이 방대한 컴포넌트 덩어리를 사용하는 곳에서 컴포넌트에 필요한 인터페이스대로 데이터를 파싱해서 사용했다.
- 아주 조금씩 데이터가 다르다. 하지만 이 다른 부분이 계속 더 많이 생겨 날 것이고, 차이가 벌어지면서 결국 나누는게 맞다! 라는 생각을 하게 됬다.
- 그런 측면에서 볼때 아직 다 나눈 것은 아니라고 생각한다.
- 왜냐하면 이 컴포넌트에 사용되는 인터페이스 자체가 계속 변할 우려가 있기 때문이다.
- 아... 결국 쪼개고 쪼개서 중복되는 것을 없애 버려야 완전히 작업이 끝날 것 같았다.
- 그래서 아직도 작업중이다... 힘들다 ㅠ
