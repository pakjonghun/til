—
date: 2024-07-11
category: til
—

## 개요

- graphql n+1 쿼리 문제 개선 및 resolver 분리

## 문제인식

- graphql 에서는 n+1 문제가 있다.
- 조회하는 어떤 db 에서 참조하는 데이터가 있다면
- 조회하는 데이터 개수만큼 참조하는 데이터를 불러오기 위해 n 번만큼 더 쿼리를 날리는 문제 인데
- 이 문제는 다행히도 data-loader 라는 방법으로 한번에 모아서 쿼리하는 방식으로 해결할수 있다.
- 해당 문제와 해결방법을 알고는 있는데
- 오랜만에 적용하려니 타입이 깨지거나 리졸버와 스키마 간에 정의되지 않은 타입이 있다고 오류가 뜨는등
- 이것저것 막히는게 많아서 기록으로 남기려고 한다.

## 타입이 다르다면 resolver 를 타입별로 나누자!

- 개발하다보면 원래 db 에서 사용하는 타입과 다르게
- 응답해줘야 해서 응답 output dto 를 별도로 만들곤 하는데
- 이 별도의 out dto 는 실제 기본 타입과 구조가 같아도 다른 타입으로 인식되므로
- 다른 타입으로 관리를 해야줘 하고
- 프론트에서 fragment 등으로 사용할때도 다른 타입으로 엄격하게 분리해서 사용해야 한다.
- 이것을 안지키고 섞어서 타입을 사용할 경우
- data-loader 사용에도 문제가 생기고
- 분명 구조가 같은 타입인데도 불구하고 사용하면 타입이 다르다며 오류가 발생한다.
- 이 문제로 몇시간 헤매다가 결국 타입별로 resolver 를 나누는 것이 답이라는 것을 알아냈다.
- 실제로 어떤 Client 라는 타입이 있으면 이 Client 타입과 유사하지만 다른 OutClient 라는 타입을 만들어서 응답 하는 resolver 끼리 별도로 모으고
- 이 OutClient 타입이 사용하는 data-loader 도 이 resolver 에 세팅을 해줘야 한다.
- 이렇게 분리하면 인터페이스가 완전히 다 바뀌는데(Client 에서 OutClient로)
- 이게 백엔드 한정 바뀌는게 아니라 프론트에서 전부 인터페이스가 깨지기 시작한다.
- 곧 인터페이스 변경으로 프론트에서 대규모 공사를 해줘야 한다.
- 그래도 정말로 꼭 바꿔야 하는 구조 변경이라면 번거롭더라도 작업을 해주는게 좋다고 생각해서
- 어처피 autogenerate code gen 기능을 사용중이라
- front 에서도 해당 인터페이스 변경 작업을 진행해서 결국 마무리 했다
- fragment 도 새로운 타입에 맞춰서 새롭게 만들어 줘야 했다.
